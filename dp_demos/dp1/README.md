# Dynamic Programming 001

### Environment

- C++ 20

### Examples

- [AtCoder D - 禁止された数字](https://atcoder.jp/contests/abc007/tasks/abc007_4)

該例題可以將問題分解為
1. 已處理的位的值是否已到達最大值
    
    如果是，則下一次的遍歷只到下一位的數值為止; 否則遍歷0~9

2. 記錄已處理的情況下的違規數字數量，並在下一次直接使用

在例題中的「入力例2」，有範圍[40, 49]。

- 考慮40的情況:
    1. 遍歷0~4
    2. 第一次操作時，十位數為0，得到個位數(idx=1)時且十位數小於4(less=true)的情況下，會有2個違規數字{04, 09}。
    3. 第二次操作時，十位數為1，條件與十位數為0時一樣，所以不需要再次偏歷計算，可以直接取得違規數字數量{14, 19}。
    4. 第三次操作時，十位數為2，直接取得違規數字數量{24, 29}。
    5. 第四次操作時，十位數為3，直接取得違規數字數量{34, 39}。
    6. 第五次操作時，十位數為4，因為less=false，所以需要重新遍歷，遍歷到個位數的值為止，這裏為0，所以只需要遍歷一次，得到1個違規數字{40}。
    7. 最終，40的違規數字總共有9個。

- 考慮49的情況:
    1. 遍歷0~4
    2. 第一次操作時，十位數為0，得到個位數(idx=1)時且十位數小於4(less=true)的情況下，會有2個違規數字{04, 09}。
    3. 第二次操作時，十位數為1，條件與十位數為0時一樣，所以不需要再次偏歷計算，可以直接取得違規數字數量{14, 19}。
    4. 第三次操作時，十位數為2，直接取得違規數字數量{24, 29}。
    5. 第四次操作時，十位數為3，直接取得違規數字數量{34, 39}。
    6. 第五次操作時，十位數為4，因為less=false，所以需要重新遍歷，遍歷到個位數的值為止，這裏為9，所以需要遍歷九次，得到10個違規數字{40, 41, 42, ..., 49}。
    7. 最終，49的違規數字總共有18個。

需要注意的是，因為[40, 49]是包含了40，所以在計算時，不應該將40的違規數字也減掉，所以需要使40-1，只考慮到39為止的違規數量。

如果該操作需要重複使用多次，也可以將`memo`設置為全局變量，已計算的結果就可以被重覆使用。但會佔用多餘的內存，所以需要程序員自行取捨。